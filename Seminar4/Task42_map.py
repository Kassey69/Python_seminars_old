# пояснение что такое  map

l = [2, 3, 5, 9, 3, 5]

'''функцию map мы можем представлять как нечто подобное'''

def my_map(f ,i): # f функция и i последовательность
    for el in i:
        yield(f(el)) 
        # print((my_map(str, l)))
'''
# yield что то похожее на return, за исключение м того что он возвращает кусочек выполненной работы
# yield возвращает генератор , когда мы вызыываем нашу функцию my_map без листа print((my_map(str, l)))
# вызывается некоторый генератор  <generator object my_map at 0x00000263805E5A80> 
# к жтому генератору мы можем оращаться спомощью next  print(next)
# '''        
var = my_map(str, l)    
print(var)
# print((my_map(str, l))) # ['2', '3', '5', '9', '3', '5']
print(next(var)) # 2
print(next(var)) # 3
print(next(var)) # 5
print(next(var)) # 9
print(next(var)) # 3
print(next(var)) # 5
# print(next(var)) # StopIteration

'''Он возвращает некоторый генератор и мы к нему через next можем обращаться и он каждый раз на next
будет вычислять следующее значение
Мы в цикле перебираем нашу последовательность. ПОлучаем каждый элемент, преобразуем этот элемент с 
помощью переданной функции и с помощью функции next мы можем получать каждый раз следующий результат
результат является конечным и в конце валится -- StopIteration
yield(f(el)) - позволяет при следующем обращении к функции получать следующий элемент
если элементов много миллион, все они не нужны и можно с помощью функции yield(f(el)) брать небольшую нужную часть'''


# l = [2, 3, 5, 9, 3, 5]

def my_map(f ,i): # f функция и i последовательность
    my_list = []
    for el in i: # и применяет функцию к каждому элементу последовательности
        my_list.append(f(el))
    return my_list
map_obj = map(str, l)
print(map_obj, type(map_obj)) # он возвращает некий мар обэект<map object at 0x00000268BB877B50> <class 'map'>
print(list(my_map(str, l)))
# list - список
'''map(функция, последовательности)'''


