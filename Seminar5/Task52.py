# Дан список чисел. Создать список, в который попадают числа, описываемые возрастающую последовательность. 
# Пример: [1, 5, 2, 3, 4, 6, 1, 7] => [1, 2, 3] или [1, 7] или [1, 6, 7] и т.д. Порядок элементов менять нельзя

# Первый вариант
nums = [1, 5, 2, 3, 4, 6, 1, 7]
def get_up2(nums):
    ups = [nums[0]] # это тоже самое что первое значение, дбавление первого элемента равного 1
    # ups = [1] 
    for i in nums:
        if i > max(ups): # мы заппустили вначале 1 элемент равный 1, если элемент следующий больше его то добавляем с список
            ups.append(i) # элемент добавляем в список
    return ups
    
print(get_up2(nums))

# Второй вариант

def get_up(nums):
    ups = []
    for i in range(len(nums)):
        if nums[i] == max(nums[:i+1:]) and nums[i] not in ups:
            # nums[:i+1:] - означает что открываются сначала элемент i = 0 + 1, а значит 1, следующий элемент
            # nums[i] = 0 - это первый элемент, а (nums[:i+1:] значит следующий за ним элемент + 1
            ups.append(nums[i])
    return ups

print(get_up(nums))


# 3 вариант
def find_chain(numbers, chain, start_pos, find_length):
    global r # глобальный результат 
    if len(chain) == find_length:   # если длина подсписка равна длине поиска
        r += [chain[:]] # мы будем добавлять список и у него забирать минус пеовый элемента 
        chain.pop(-1) # у него забирать минус пеhвый элемента 
        return # если длина нашего поискового подсписка равна длине которую мы ищем, то мы в результат записываем копию
        # нашего подсписка и затем убираем из него последний элемент и возвращаем полученный результат
    # если длина подсписка не равна длине поиска то мы начинаем входить
    for i in range(start_pos, len(numbers)): # мы начинаем входить в диапазон стартовой позиции start_pos, нулевая позиция 
                                             # до длины списка len(numbers)
        if len(chain) < find_length: # проверяем - если длина подсписка len(chain) меньше длине поиска find_length
            if len(chain) > 0: # и если длина подсписка len(chain) > 0
                if chain[len(chain)-1] < numbers[i]: # и если взятый предыдущий последний элемента меньше текущего, 
                    chain.append(numbers[i]) # если словие верно то мы в chain добавляем текущий элемент
                    find_chain(numbers, chain, i, find_length) # мы вызываем нашщу функцию, передаем в нее
            else: 
                chain.append(numbers[i])
                find_chain(numbers, chain, i, find_length)
    ''' если длина подсписка len(chain) > 0 , то мы добавлчяем итый элемент из списка hain.append(numbers[i]) 
        и снова вызываем эту же функцию find_chain(numbers, chain, i, find_length)'''
    if len(chain) > 0: # если длина подсписка len(chain) > 0
        chain.pop(-1) # мы убираем у него минус элемент
    '''постепенно мы переходим на большую длину и перебираем все варианты'''
numbers = [1, 5, 2, 3] # список содержащий все числа
chain = []           # подсписок, изначально он будет пустой
r = []           # результирующий список
for find_lengt in range(2, len(numbers)): # исходи от второго элемента, первым шагом мы будем проверять 1 и 5, поэтому со 2 элемента
    find_chain(numbers, chain, 0 , find_lengt) # n -число, chain -последовательность, 0 -стартовая позиция, i какую длину мы будем искать
        # дилна списка должна быть больше либо равна 2 элементам, но меньше длине всего списка 
        # поэтому мы начинаем со второго элемента
print(r)