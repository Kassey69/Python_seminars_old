# 34  -----------------сдал как 33
# Задана натуральная степень k. Сформировать случайным образом список коэффициентов 
# (значения от 0 до 100) многочлена и записать в файл многочлен степени k. 
# *Пример: 
# k=2 => 2*x² + 4*x + 5 = 0 или x² + 5 = 0 или 10*x² = 0


                                            
'''degree^ - дуга^ - степень^
                             reduce - редкий - уменьшение'''
import random
          
def get_polynom(degree):
    polynom_str = '' # создаем стринговую пустую строку
    for i in range(degree, -1, -1): # мы используем диапазон целых чисел от degree рандомного числа и до -1 с шагом -1
        # -1 шаг значит в обратную сторону; -1 ВТОРОЕ ЧИСЛО это мы захватываем и 0, где будет наше число без икса х
        a = random.randint(0, 100) # получаем некое рандомное число random.randint(0, 100)
        print(i,degree) # 0 10
        if a != 0: # если a != 0 это условие при котром значение а цифра перед х не будлет равно 0
            if i == degree and i != 1: # это охначает обращение к первому числу слева !!!!!!!!!!!!!!!!
                polynom_str += str(a) + '*x^' + str(i) # это первое число в уравнении слева
            # elif i == degree and i == 1: # это обращение ко всем числам, оно лищнее
            #     polynom_str += str(a) + 'x'
            elif i == 1: # это обращение конкретно к элементу 2 или индексу элемента 1 в строке от нуля
                polynom_str += ' + ' + str(a) + '*x' # переделывыаем в этом элементе 'x^' на 'x'
            elif i == 0: # это обращение конкретно к элементу 1 или индексу элемента 0 в строке от нуля
                polynom_str += ' + ' + str(a) # тут мы оставляем число   
               # по сути выше у нас рабираются три элемента последний, первый и второй
            else: # и else говорит, что теперь всем остальным элементам кроме трех что выше присваиваем следующее
                polynom_str += ' + ' + str(a) + '*x^' + str(i) #  + цифра + х + степень
    return polynom_str + ' = 0' # сдесь написано -- возвращаем все уроавнение и приписываем = 0

degree = random.randint(3,10)
result = get_polynom(degree)
print(f'Многочлен степени {degree}: {result}') # 64x^6 + 16x^5 + 87x^4 + 64x^3 + 51x^2 + 8x + 87 = 0


'''2 вариант '''
import random
from functools import reduce
import re

''' Функция sub() модуля re возвращает строку, полученную путем замены крайнего левого 
неперекрывающегося вхождения шаблона регулярного выражения pattern в строке string на строку замены repl. 
Если шаблон регулярного выражения не найден, строка возвращается без изменений.'''

def normalize_polynom(polynom_str): # общепринятые сокращения
    print(polynom_str) # 64x^5 + 23x^4 + 17x^3 + 98x^2 + 92x^1 + 14x^0 + 
    polynom_str = re.sub(r'\b0x\^\d+ \+ ', r'', polynom_str)     # 0x^k' -> '' убирает такой символ, потому что 0
    polynom_str = re.sub(r'\b1x\^(\d+)', r'x\^\1', polynom_str)  # 1x^k' -> 'x^k' убирает 1 если встречается в цифре
    # polynom_str = re.sub(r'(\d+)x\^1', r'\1x', polynom_str)      # nx^1' -> 'nx' удаляем 1 в степени
    polynom_str = re.sub(r'(\d+)x\^0', r'\1', polynom_str)       # nx^0' -> 'n' последнее число справа индекс 0 
    print(polynom_str) # 64x^5 + 23x^4 + 17x^3 + 98x^2 + 92x + 14 + 
    return polynom_str

def get_polynom_x(k):
    polynom_list = [str(random.randint(0, 100)) + 'x^' + str(n) + ' + ' for n in range(k, -1, -1)]
    # n будет каждый раз уменьшаться на -1 и идти назад -1 получаем некое рандомное число random.randint(0, 100)
    # канкетенироуем его с 'x^' и канкетинируем его со строковым представлением нашего числа полученного str(n) степень
    # и прибавляем + ' + '
    # мы берем диапазон числа к до -1 с шагом -1    # получим обратный счет 6 5 4 3 2 1 0
    # polynom_str = reduce(lambda x, y: x + y, polynom_list) # объединяется весь список уравнения через reduce
    polynom_str = ''.join(polynom_list) # строки можно соединять проще через join если не нужно посчитать интовое значение
    polynom_str = normalize_polynom(polynom_str)
    return polynom_str[: -3] + ' = 0' # это означает отступить с конца 3 символа удалив содержимое и заполнив его ' = 0'
'''функция reduce получает последовательность polynom_list и она складывает всю последовательность'''
'''reduce(lambda x, y: x + y, polynom_list) объединяется весь список'''
'''    ПРИМЕР
    # polynom_list = '1', '2', '3', '4', '5'
    # polynom_str = reduce(lambda x, y: x + y, polynom_list)
    # print(polynom_str) # 12345
    чтобы получить сумму элементов нужно перевести в интовое значение
    polynom_str = reduce(lambda x, y: int(x) + int(y), polynom_list) # в этом случае print выдаст результат = 15
    # print(polynom_str) # 15'''

# тест
import os
k = random.randint(1, 10)
polynom = get_polynom_x(k)
print(f'Полином степени {k}: {polynom}') # Полином степени 5: 64x^5 + 23x^4 + 17x^3 + 98x^2 + 92x + 14 = 0

with open('ex_48_out.txt', 'w') as data:
    data.write(polynom)


'''3 вариант изменённый'''
import random
from functools import reduce
import re
'''ОНО УЖЕ НЕ НУЖНО!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'''
def normalize_polynom(polynom_str): # общепринятые сокращения
    print(polynom_str) # 64x^5 + 23x^4 + 17x^3 + 98x^2 + 92x^1 + 14x^0 + 
    polynom_str = re.sub(r'\b0x\^\d+ \+ ', r'', polynom_str)     # 0x^k' -> '' убирает такой символ, потому что 0
    polynom_str = re.sub(r'\b1x\^(\d+)', r'x\^\1', polynom_str)  # 1x^k' -> 'x^k' убирает 1 если встречается в цифре
    # polynom_str = re.sub(r'(\d+)x\^1', r'\1x', polynom_str)      # nx^1' -> 'nx' удаляем 1 в степени
    polynom_str = re.sub(r'(\d+)x\^0', r'\1', polynom_str)       # nx^0' -> 'n' последнее число справа индекс 0 
    print(polynom_str) # 64x^5 + 23x^4 + 17x^3 + 98x^2 + 92x + 14 + 
    return polynom_str
'''!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'''
def get_polynom_x(k):
    polynom_list = ''
    # polynom_list = [str(random.randint(0, 100)) + 'x^' + str(n) + ' + ' for n in range(k, -1, -1)]

    '''Несколько if означает, что ваш код будет идти и проверять все условия if, 
    где, как и в случае elif, если одно условие if удовлетворяет, оно не будет проверять другие условия..'''
    
    for n in range(k, -1, -1):
        a = str(random.randint(0, 100))             
        if n == 1: 
                polynom_list += str(a) + 'x'+ ' + '
        elif n == 0: 
                polynom_list += str(a)
        else:
                polynom_list += str(a) + 'x^' + str(n) + ' + '     
    polynom_str = ''.join(polynom_list) # строки можно соединять проще через join если не нужно посчитать интовое значение
    polynom_str = normalize_polynom(polynom_str)
    return polynom_str + ' = 0' # ъто означает отступить с конца 3 символа удалив содержимое и заполнив его ' = 0'

# тест
import os
k = random.randint(10, 10)
polynom = get_polynom_x(k)
print(f'Полином степени {k}: {polynom}') # Полином степени 5: 64x^5 + 23x^4 + 17x^3 + 98x^2 + 92x + 14 = 0



'''4 вариант '''
from random import randint
import itertools

k = randint(3, 10) # рандом степень

def get_ratios(k):
    ratios = [randint(0, 100) for i in range (k + 1)] # берет коэффициент и +1 следующий из начального числа рандома
    # b так заполняют список ratios
    while ratios[0] == 0: # пока  нулевой коэффициент = 0
        ratios[0] = randint(1, 10) # рандомные числа присваиваются к нулевому коэффициенту
    return ratios
print(get_ratios(k)) # только смотреть надо ниже в принтах конечных, будет другой рандом а не этот [9, 9, 4, 8]

def get_polynomial(k, ratios): # в функции задействовано степень х  и прошлые полученные числа
    var = ['*x^']*(k-1) + ['*x'] # это не метод а просто кто то так назвал var !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    print(var) # ['*x^', '*x^', '*x']
    polynomial = [[a, b, c] for a, b, c  in itertools.zip_longest(ratios, var, range(k, 1, -1), fillvalue = '') if a !=0]
    # беется 3 аргумента нужные нам для каждого элемента уравнения , запускается цикл в itertools.zip_longest
    # b сопоставляют цифры - ratios, иксы с знаком умножения - var, обэединяют в картэж с последовательностью 
    # от рандом степени к до 1 с шагом -1, значит обратный варинат от большего к меньшему, все лишнее выкидывается
    # а пропущенные элементы заполняются значением fillvalue.'''при этом выполняется условие если a !=0
    '''Функция zip_longest() модуля itertools создает итератор, который объединяет элементы из каждой 
    итерируемой последовательности *iterables в кортежи.

    Отличие функции itertools.zip_longest() от встроенной функции zip() заключается в том, что zip() 
    останавливается по исчерпании самой короткой входной последовательности и отбрасывает несопоставимые 
    значения более длинных итераций, в то время как itertools.zip_longest() работает пока самая длинная 
    итерация не будет исчерпана, а пропущенные элементы заполняются значением fillvalue.'''
    print(polynomial) # [[5, '*x^', 3], [10, '*x^', 2], [9, '*x', ''], [5, '', '']]
    for x in polynomial:
        x.append(' + ') # берем каждый элемент x списка polynomial и присваиваем между ними (' + ')
    polynomial = list(itertools.chain(*polynomial)) # составление нового большого списка через list
    print(polynomial) # [5, '*x^', 3, ' + ', 10, '*x^', 2, ' + ', 9, '*x', '', ' + ', 5, '', '', ' + ']
    polynomial[-1] = ' = 0' # присваиваем polynomial на месте последнего элемента [-1] концовку уравнения ' = 0'
    print(polynomial) # [5, '*x^', 3, ' + ', 10, '*x^', 2, ' + ', 9, '*x', '', ' + ', 5, '', '', ' = 0']
    return "".join(map(str, polynomial)).replace(' 1*x',' x') # составляет стринговый вариант записи jpin
    # с помощью мар создаем новую коллекцию стринговых элементов из polynomial. заменяем на ходу если есть(' 1*x',' x')

'''map() — это встроенная функция, которая позволяет обрабатывать и преобразовывать все элементы 
в итерируемом объекте без использования явного цикла for, методом, широко известным как сопоставление (mapping). 
map() полезен, когда вам нужно применить функцию преобразования к каждому элементу в коллекции 
или в массиве и преобразовать их в новый массив.'''

ratios = get_ratios(k)
print(ratios) # [5, 10, 9, 5]
polynom1 = get_polynomial(k, ratios)
print(polynom1) # 9*x^3 + 10*x^2 + 9*x + 7 = 0

with open('33_Polynomial.txt', 'w') as data: # ну а тут открываем файл и принудительно записываем в него
    data.write(polynom1)


