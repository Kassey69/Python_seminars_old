# Функции по вызову другово файла
# Вызываем Task23_main
# from Task23_main import new_string
# print(new_string('!', 5))

# file = open('E:\Programming\Visual_Studio_Code\Python_seminars\Seminar2\Task21_DZ.py', 'r') # r - читаем
file = open('E:\Programming\Visual_Studio_Code\Python_seminars\Seminar2\Task21_DZ.py') # работает и так если только чтение
print(file.read())

'''Функция open() в Python, открывает файл на чтение/запись.
 https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-open

 Значения аргумента mode:

r - открывает файл только для чтения,
w - открыт для записи (перед записью файл будет очищен),
x - эксклюзивное создание, бросается исключение FileExistsError, если файл уже существует.
a - открыт для добавления в конец файла (на некоторых Unix-системах пишет в конец файла вне зависимости от позиции курсора)
+ - символ обновления (чтение + запись).
t - символ текстового режима.
b - символ двоичного режима (для операционных систем, которые различают текстовые и двоичные файлы).'''

# если у нас возникнет какое то исключение то файл повиснет в оперативной памяти
'''поэтому лучше всего использовать менеджер контекста'''

with open('E:\Programming\Visual_Studio_Code\Python_seminars\Seminar2\Task21_DZ.py', 'r') as F_N:
    print(F_N.read())
# менеджер контекста даже если возникнут исключения, он файл отловит и закроет
'''With ... as - менеджеры контекста https://pythonworld.ru/osnovy/with-as-menedzhery-konteksta.html'''


'''реализуем феунцию которая будет аппэндить в список некоторое значение'''

def my_append(val, my_list=[]): # ставим значения по умолчанию
    my_list.append(val)
    return my_list

print(my_append('werff23'))
print(my_append('werff23'))
print(my_append('werff23'))
print(my_append('werff23'))
print(my_append('werff23'))

'''Список это изменяемый тип данных и соответственно конгда мы передаем только ключ без списка то он изменяет
тот список , который был изначально создан, во время чтения программы
Мы можем использовать по умолчанию только изменяемые типы данных
Если мы хотим чтобы у нас было изменяемые мутабельный тип данных по умолчанию то мы моджем его передать
а можем и не передать
мы можем прописать таким образом
что изначально он будет как None ---        def my_append(val, my_list=None):
но надо сделать проверку    --------            if my_list is None:
тогда  my_list просто список                    my_list = [] 
                                                my_list.append(val)
                                                return my_list'''
                                                
def my_append(val, my_list=None):
    if my_list is None:
        my_list = [] 
    my_list.append(val)
    return my_list
print(my_append('werff23'))
print(my_append('werf33f23'))

'''Добавляем рандомную строку к созданию функции списка'''
import random
import string
def generate_alphanum_random_string(length):
    length = random.randint(7,9)
    for i in range(length):
        # Чтобы сгенерировать буквенно-цифровую случайную строку в Python, 
        # используйте константы string.ascii_letters и string.digits, чтобы получить комбинации букв и цифр.-
        letters_and_digits = string.ascii_letters + string.digits
        rand_string = ''.join(random.sample(letters_and_digits, length))
        # print("Рандомная строка", length, "символов:", rand_string)
    return rand_string
strika2 = ''
print("Просто рандомная строка", generate_alphanum_random_string(strika2))

print("Рандомная строка с фукнцией создания списка", my_append(generate_alphanum_random_string(strika2)))
print("Рандомная строка с фукнцией создания списка", my_append(generate_alphanum_random_string('strika2'))) # можно так
'''-------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------'''

'''У словаря ключами могут быть только неизменяемые типы данных'''
'''Картэж у нас неизменяемый тип данных'''

'''Картэж может быть ключом словаря
                и да и нет'''

# Создадим картэж в котором будут храниться неизменяемые типы данных
c = (1, 2, 3)
# и создадим словарь, в котором будет ключом наш картэж , а значением будет строка
d = {c: 'wefwfe'}
# и выведем его на печать
print(d)

'''добавим к неизменяемому типу данных список и произойдет ошибка
c = (1, 2, 3,[])
d = {c: 'wefwfe'}
print(d) # TypeError: unhashable type: 'list' - ошибка'''

'''он проверяет рекурсивно вглубь , всю вложенность картэжа и если в нем присутствует изменяемый тип данных то будет
валиться с ошибкой  и это одинакого работает для всех мутабельных типов данных [] {}
c = (1, 2, 3,(1, 2 (1, 2, [])))
d = {c: 'wefwfe'}
print(d)'''

'''c = (1, 2, 3,(1, 2 (1, 2, set([])))) в том числе и с мнодеством не работает'''
'''-------------------------------------------------------------------------------------------------------------------'''

'''По спискам, список это изменяемый тип данных'''

a = [1, 2, 3]
b = a
b.append(222)
print(a) # [1, 2, 3, 222]


a = [1, 2, 3]
b = a.copy() # можно через срез скопировать b = a[:]
# b = a[:] # срез нам возвращает тот же самый обьект
b.append(222)
print(a) # [1, 2, 3]
print('_'*60) # ____________________________________________________________
print(b) # [1, 2, 3, 222]

from copy import deepcopy # используется если надо сделать глубокое копирование с вложенностями
a = [1, 2, 3, [1, 2, 3]] # глубокое копирование с вложенностями
b = deepcopy(a) # срез нам возвращает тот же самый обьект
b[3].append(333)
print(a) # [1, 2, 3, [1, 2, 3]]
print('_'*30)  # это линия разделительная между решениями _____________________________
print(b) # [1, 2, 3, [1, 2, 3, 333]]